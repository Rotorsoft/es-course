import type { Committed, EventMeta, Lease, Message, Query, Schemas, Store } from "../types/index.js";
/**
 * In-memory event store implementation.
 *
 * This is the default store used by Act when no other store is injected.
 * It stores all events in memory and is suitable for:
 * - Development and prototyping
 * - Unit and integration testing
 * - Demonstrations and examples
 *
 * **Not suitable for production** - all data is lost when the process exits.
 * Use {@link PostgresStore} for production deployments.
 *
 * The in-memory store provides:
 * - Full {@link Store} interface implementation
 * - Optimistic concurrency control
 * - Stream leasing for distributed processing simulation
 * - Snapshot support
 * - Fast performance (no I/O overhead)
 *
 * @example Using in tests
 * ```typescript
 * import { store } from "@rotorsoft/act";
 *
 * describe("Counter", () => {
 *   beforeEach(async () => {
 *     // Reset store between tests
 *     await store().seed();
 *   });
 *
 *   it("increments", async () => {
 *     await app.do("increment", target, { by: 5 });
 *     const snapshot = await app.load(Counter, "counter-1");
 *     expect(snapshot.state.count).toBe(5);
 *   });
 * });
 * ```
 *
 * @example Explicit instantiation
 * ```typescript
 * import { InMemoryStore } from "@rotorsoft/act";
 *
 * const testStore = new InMemoryStore();
 * await testStore.seed();
 *
 * // Use for specific test scenarios
 * await testStore.commit("test-stream", events, meta);
 * ```
 *
 * @example Querying events
 * ```typescript
 * const events: any[] = [];
 * await store().query(
 *   (event) => events.push(event),
 *   { stream: "test-stream" }
 * );
 * console.log(`Found ${events.length} events`);
 * ```
 *
 * @see {@link Store} for the interface definition
 * @see {@link PostgresStore} for production use
 * @see {@link store} for injecting stores
 *
 * @category Adapters
 */
export declare class InMemoryStore implements Store {
    private _events;
    private _streams;
    /**
     * Dispose of the store and clear all events.
     * @returns Promise that resolves when disposal is complete.
     */
    dispose(): Promise<void>;
    /**
     * Seed the store with initial data (no-op for in-memory).
     * @returns Promise that resolves when seeding is complete.
     */
    seed(): Promise<void>;
    /**
     * Drop all data from the store.
     * @returns Promise that resolves when the store is cleared.
     */
    drop(): Promise<void>;
    private in_query;
    /**
     * Query events in the store, optionally filtered by query options.
     * @param callback - Function to call for each event.
     * @param query - Optional query options.
     * @returns The number of events processed.
     */
    query<E extends Schemas>(callback: (event: Committed<E, keyof E>) => void, query?: Query): Promise<number>;
    /**
     * Commit one or more events to a stream.
     * @param stream - The stream name.
     * @param msgs - The events/messages to commit.
     * @param meta - Event metadata.
     * @param expectedVersion - Optional optimistic concurrency check.
     * @returns The committed events with metadata.
     * @throws ConcurrencyError if expectedVersion does not match.
     */
    commit<E extends Schemas>(stream: string, msgs: Message<E, keyof E>[], meta: EventMeta, expectedVersion?: number): Promise<Committed<E, keyof E>[]>;
    /**
     * Polls the store for unblocked streams needing processing, ordered by lease watermark ascending.
     * @param lagging - Max number of streams to poll in ascending order.
     * @param leading - Max number of streams to poll in descending order.
     * @returns The polled streams.
     */
    poll(lagging: number, leading: number): Promise<{
        stream: string;
        source: string | undefined;
        at: number;
        lagging: boolean;
    }[]>;
    /**
     * Lease streams for processing (e.g., for distributed consumers).
     * @param leases - Lease requests for streams, including end-of-lease watermark, lease holder, and source stream.
     * @param leaseMilis - Lease duration in milliseconds.
     * @returns Granted leases.
     */
    lease(leases: Lease[], millis: number): Promise<Lease[]>;
    /**
     * Acknowledge completion of processing for leased streams.
     * @param leases - Leases to acknowledge, including last processed watermark and lease holder.
     */
    ack(leases: Lease[]): Promise<{
        stream: string;
        source: string | undefined;
        at: number;
        by: string;
        retry: number;
        lagging: boolean;
    }[]>;
    /**
     * Block a stream for processing after failing to process and reaching max retries with blocking enabled.
     * @param leases - Leases to block, including lease holder and last error message.
     * @returns Blocked leases.
     */
    block(leases: Array<Lease & {
        error: string;
    }>): Promise<{
        stream: string;
        source: string | undefined;
        at: number;
        by: string;
        retry: number;
        error: string;
        lagging: boolean;
    }[]>;
}
//# sourceMappingURL=InMemoryStore.d.ts.map