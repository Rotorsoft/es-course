/**
 * @module projection-builder
 * @category Builders
 *
 * Fluent builder for composing projection handlers — read-model updaters
 * that react to events and update external state (databases, caches, etc.).
 *
 * Projections differ from slices: they don't contain states, don't dispatch
 * actions, and are pure side-effect handlers routed to a named stream.
 */
import type { ZodType } from "zod";
import type { Committed, EventRegister, ReactionResolver, Schema, Schemas } from "./types/index.js";
/**
 * A self-contained projection grouping read-model update handlers.
 * Projections are composed into an Act orchestrator via `act().with(projection)`.
 *
 * @template E - Event schemas handled by this projection
 */
export type Projection<E extends Schemas> = {
    readonly _tag: "Projection";
    readonly events: EventRegister<E>;
};
/**
 * Type guard for distinguishing Projection from State and Slice objects.
 */
export declare function isProjection(x: any): x is Projection<any>;
/** Helper: a single-key record mapping an event name to its Zod schema. */
type EventEntry<K extends string = string, D extends Schema = Schema> = {
    [P in K]: ZodType<D>;
};
/** Infer the handler-result type after registering one event. */
type DoResult<E extends Schemas, K extends string, D extends Schema> = ProjectionBuilder<E & {
    [P in K]: D;
}> & {
    to: (resolver: ReactionResolver<E & {
        [P in K]: D;
    }, K> | string) => ProjectionBuilder<E & {
        [P in K]: D;
    }>;
    void: () => ProjectionBuilder<E & {
        [P in K]: D;
    }>;
};
/**
 * Fluent builder interface for composing projections.
 *
 * Provides a chainable API for registering event handlers that update
 * read models. Unlike slices, projections have no `.with()` for states
 * and handlers do not receive a `Dispatcher`.
 *
 * When a default target is provided via `projection("target")`, all
 * handlers inherit that resolver. Per-handler `.to()` or `.void()` can
 * still override it.
 *
 * @template E - Event schemas
 */
export type ProjectionBuilder<E extends Schemas> = {
    /**
     * Begins defining a projection handler for a specific event.
     *
     * Pass a `{ EventName: schema }` record — use shorthand `{ EventName }`
     * when the variable name matches the event name. The key becomes the
     * event name, the value the Zod schema.
     */
    on: <K extends string, D extends Schema>(entry: EventEntry<K, D>) => {
        do: (handler: (event: Committed<E & {
            [P in K]: D;
        }, K>, stream: string) => Promise<void>) => DoResult<E, K, D>;
    };
    /**
     * Builds and returns the Projection data structure.
     */
    build: () => Projection<E>;
    /**
     * The registered event schemas and their reaction maps.
     */
    readonly events: EventRegister<E>;
};
/**
 * Creates a new projection builder for composing read-model update handlers.
 *
 * Projections enable separation of read-model concerns from command handling.
 * Each `.on({ Event }).do(handler)` call registers a handler that updates
 * a projection (database table, cache, etc.) in response to events.
 *
 * Pass a target stream name to `projection("target")` so every handler
 * inherits that resolver automatically. Omit it and use per-handler
 * `.to()` / `.void()` when handlers route to different streams.
 *
 * @param target - Optional default target stream for all handlers
 *
 * @example Default target (all handlers routed to "tickets")
 * ```typescript
 * const TicketProjection = projection("tickets")
 *   .on({ TicketOpened })
 *     .do(async ({ stream, data }) => {
 *       await db.insert(tickets).values({ id: stream, ...data });
 *     })
 *   .on({ TicketClosed })
 *     .do(async ({ stream, data }) => {
 *       await db.update(tickets).set(data).where(eq(tickets.id, stream));
 *     })
 *   .build();
 * ```
 *
 * @example Per-handler routing
 * ```typescript
 * const MultiProjection = projection()
 *   .on({ OrderPlaced })
 *     .do(async (event) => { ... })
 *     .to("orders")
 *   .on({ PaymentReceived })
 *     .do(async (event) => { ... })
 *     .to("payments")
 *   .build();
 * ```
 *
 * @see {@link ProjectionBuilder} for builder methods
 * @see {@link Projection} for the output type
 */
export declare function projection<E extends Schemas = {}>(target?: string, events?: EventRegister<E>): ProjectionBuilder<E>;
export {};
//# sourceMappingURL=projection-builder.d.ts.map